View(test2)
View(test2)
View(test)
View(test2)
View(test)
View(test2)
View(test)
View(test2)
View(surrMatrix.old)
View(test)
View(test2)
View(test)
View(test2)
View(test)
View(test2)
View(test)
View(test)
View(test2)
View(test)
library(SurrogateMinimalDepth)
?var.select.mir
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
library("R.utils")
test = loadObject(file = "/home/stephan/Projekte/mutualginiimpurity/subprojects/03_ComparisonStudy_SimStudy3/data/gene_expression_array/simulation/classification/effects_-2_-1_-0.5_0.5_1_2/samples_200/causal.var_150/results/ntree_ 5000 _mtry_p34/mir/par_500_0.01/results_rep_1_data_set_1.RData")
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
data = SMD_example_data
x = data[,2:ncol(data)]
y = data[,1]
ntree = 5
type = "regression"
s = 10
mtry = NULL
min.node.size = 1
num.threads = NULL
status = NULL
save.ranger = FALSE
create.forest = TRUE
forest = NULL
save.memory = FALSE
min.var.p = 200
p.t.sel = 0.01
p.t.rel = 0.01
select.var = TRUE
case.weights = NULL
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights)
rel = var.relations.corr(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
select.rel = FALSE
rel = var.relations.corr(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
method.rel = "janitza"
rel = var.relations.corr(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
if (create.forest) {
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = sapply(1:ncol(x),permute.variable,x=x)
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
x_perm = sapply(1:ncol(x),permute.variable,x=x)
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
#' permute.variable
#'
#' This is an internal function
#'
#' @keywords internal
permute.variable=function(i=1,x){
var.perm = sample(x[,i],nrow(x))
return(var.perm)
}
#' p.relation
#'
#' This is an internal function
#'
#' @keywords internal
p.relation = function(l = 1,
null.rel,
adj.agree.corr,
candidates,
variables) {
relations = adj.agree.corr[l,]
pval <- 1 - ranger:::numSmaller(relations, null.rel) / length(null.rel)
names(pval) = candidates
pval[variables[l]] = NA
return(pval)
}
#' select.related
#'
#' This is an internal function
#'
#' @keywords internal
select.related = function(m=1,
rel.p,
p.t) {
rel.var = rel.p[[m]]
names(which(rel.var <= p.t))
}
x_perm = sapply(1:ncol(x),permute.variable,x=x)
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
rel = meanAdjAgree(forest$trees, variables = allvariables, allvariables = allvariables, candidates = allvariables,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights)
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights)
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
s = count.surrogates(forest$trees)
rel = meanAdjAgree(forest$trees, variables = allvariables, allvariables = allvariables, candidates = allvariables,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
results.allvar = t(sapply(1:length(index.variables),maa.p,allvariables,ntree,trees,index.variables,candidates,num.threads))
#' maa.p
#'
#' This is an internal function
#'
#' @keywords internal
maa.p=function(p=1,allvariables,ntree,trees,index.variables,candidates,num.threads){
i=index.variables[p]
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
colnames(surrMatrix)=allvariables
means.surr=colMeans(surrMatrix,na.rm=TRUE)
means.surr[i]=NA
means.surr.candidate=means.surr[candidates]
means.surr.candidate[which(means.surr.candidate == "NaN")] = NA
return(means.surr.candidate)
}
#' surr.var
#'
#' This is an internal function
#'
#' @keywords internal
surr.var=function(i=1,variables,ntree,trees){
surrMatrix=t(sapply(1:ntree,surr.tree,variables,ntree,trees,i))
colnames(surrMatrix)=variables
means.surr=colMeans(surrMatrix,na.rm=TRUE)
return(means.surr)
}
#' surr.tree
#'
#' This is an internal function
#'
#' @keywords internal
surr.tree=function(tree,variables,ntree,trees,i){
adjtree=rep(0,length(variables))
# there are more than one nonterminal nodes with split variable i
if (length(which(sapply(tree,"[[",4)==i))>1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
s=sapply(nodes,length)
s=(s-7)/2
surr=lapply(nodes,"[",-c(1:7)) # extract surrogates
sum=0
for (o in 1:length(s)) {
if (s[o]==0) next
adjtree.k=rep(0,length(variables))
surr.var=surr[[o]][(1:s[o])]
surr.adj=surr[[o]][(s[o]+1):(2*s[o])]
adjtree.k[surr.var]=surr.adj
adjtree=adjtree+adjtree.k
sum=sum+1
}
adjtree=adjtree/sum
}
#there is one nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
surr=sapply(nodes,"[",-c(1:7)) # extract surrogates
if ((length(nodes[[1]]))>7){
s=(length(surr))/2
surr.var=surr[1:s]
surr.adj=surr[(s+1):(2*s)]
adjtree[surr.var]=surr.adj
}
}
#there is no nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==0){
adjtree=rep(NA,length(variables))
surr.mean=NA
}
return(adjtree=adjtree)
}
#' adj.mean
#'
#' This is an internal function
#'
#' @keywords internal
adj.mean=function(trees){
adj.trees=sapply(1:length(trees),adj.mean.trees,trees)
}
#' adj.mean.trees
#'
#' This is an internal function
#'
#' @keywords internal
adj.mean.trees=function(t,trees){
tree=trees[[t]]
nonterminal.nodes=tree[which(sapply(tree,"[[","status")==1)]
surr.nonterminal=lapply(nonterminal.nodes,"[",-c(1:7))
adj.tree=mean(unlist(lapply(1:length(surr.nonterminal),adj.node,surr.nonterminal)),na.rm = TRUE)
if (adj.tree == "NaN") {
adj.tree = NA
}
return(adj.tree)
}
#' adj.node
#'
#' This is an internal function
#'
#' @keywords internal
adj.node=function(m,surr.nonterminal){
surr=surr.nonterminal[[m]]
if (length(surr)!=0){
num.surr=length(surr)/2
adj=surr[(num.surr+1):(2*num.surr)]
}
if (length(surr)==0){
adj=NA
}
return(adj)
}
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
results.allvar = t(sapply(1:length(index.variables),maa.p,allvariables,ntree,trees,index.variables,candidates,num.threads))
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
variables = allvariables
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
results.allvar = t(sapply(1:length(index.variables),maa.p,allvariables,ntree,trees,index.variables,candidates,num.threads))
index.variables
p = 1
i=index.variables[p]
i=index.variables[p]
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
tree = trees[1]
adjtree=rep(0,length(variables))
adjtree
# there are more than one nonterminal nodes with split variable i
if (length(which(sapply(tree,"[[",4)==i))>1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
s=sapply(nodes,length)
s=(s-7)/2
surr=lapply(nodes,"[",-c(1:7)) # extract surrogates
sum=0
for (o in 1:length(s)) {
if (s[o]==0) next
adjtree.k=rep(0,length(variables))
surr.var=surr[[o]][(1:s[o])]
surr.adj=surr[[o]][(s[o]+1):(2*s[o])]
adjtree.k[surr.var]=surr.adj
adjtree=adjtree+adjtree.k
sum=sum+1
}
adjtree=adjtree/sum
}
#there is one nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
surr=sapply(nodes,"[",-c(1:7)) # extract surrogates
if ((length(nodes[[1]]))>7){
s=(length(surr))/2
surr.var=surr[1:s]
surr.adj=surr[(s+1):(2*s)]
adjtree[surr.var]=surr.adj
}
}
#there is no nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==0){
adjtree=rep(NA,length(variables))
surr.mean=NA
}
surrMatrix=matrix(unlist(lapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
surrMatrix=matrix(unlist(lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
surrMatrix=parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)
surrMatrix=lapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
tree
tree = trees[[1]]
trees
trees
forest$trees
trees = forest$trees
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
tree = trees[1]
tree
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
tree
surrMatrix=lapply(tree,surr.tree,allvariables,ntree,i)
t
i
trees
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
i=index.variables[p]
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
i
#' surr.tree
#'
#' This is an internal function
#'
#' @keywords internal
surr.tree=function(tree,variables,ntree,i){
adjtree=rep(0,length(variables))
# there are more than one nonterminal nodes with split variable i
if (length(which(sapply(tree,"[[",4)==i))>1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
s=sapply(nodes,length)
s=(s-7)/2
surr=lapply(nodes,"[",-c(1:7)) # extract surrogates
sum=0
for (o in 1:length(s)) {
if (s[o]==0) next
adjtree.k=rep(0,length(variables))
surr.var=surr[[o]][(1:s[o])]
surr.adj=surr[[o]][(s[o]+1):(2*s[o])]
adjtree.k[surr.var]=surr.adj
adjtree=adjtree+adjtree.k
sum=sum+1
}
adjtree=adjtree/sum
}
#there is one nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
surr=sapply(nodes,"[",-c(1:7)) # extract surrogates
if ((length(nodes[[1]]))>7){
s=(length(surr))/2
surr.var=surr[1:s]
surr.adj=surr[(s+1):(2*s)]
adjtree[surr.var]=surr.adj
}
}
#there is no nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==0){
adjtree=rep(NA,length(variables))
surr.mean=NA
}
return(adjtree=adjtree)
}
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
View(surrMatrix)
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
View(surrMatrix)
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100)
res$var
13 * 97.33
13 * 97.33 / 22.362
0.328/0.175
