trees.surr=addSurrogates(RF=RF,trees=trees.lay,s=s,Xdata=x)
# count surrogates
s=count.surrogates(trees.surr)
surrminimaldepth.s=surrmindep(variables,trees.surr,s.l=s$s.l)
results=list(info=surrminimaldepth.s,var=names(surrminimaldepth.s$selected[surrminimaldepth.s$selected == 1]),trees=trees.surr)
return(results)
}
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10)
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10,ntree=10)
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10,ntree=10,num.threads = 1)
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10,ntree=10)
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10,ntree=10,num.threads = 1)
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10,ntree=100)
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10,ntree=100,num.threads = 1)
devtools::document()
library(SurrogateMinimalDepth)
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10)
res$var
devtools::document()
library(SurrogateMinimalDepth)
devtools::document()
library(SurrogateMinimalDepth)
devtools::document()
library(SurrogateMinimalDepth)
devtools::document()
?ranger
devtools::document()
library(SurrogateMinimalDepth)
View(SMD_example_data)
devtools::document()
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
###### use data
# get trees and variable names
x=SMD_example_data[,2:ncol(SMD_example_data)]
y=SMD_example_data[,1]
allvariables=colnames(x)# extract variables names
nvar=length(allvariables)   # count number of variables
RF=ranger::ranger(data=SMD_example_data,dependent.variable.name="y",num.trees=100,keep.inbag = TRUE,mtry=floor(nvar^(3/4)))
trees=getTreeranger(RF=RF,ntree=ntree)
trees=getTreeranger(RF=RF,ntree=100)
trees.lay=addLayer(trees)
trees.surr=addSurrogates(RF=RF,trees=trees.lay,s=10,Xdata=x)
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
#' Investigate variable relations of a specific variable with mean adjusted agreement
#'
#'This function uses the parameter adjusted agreement to select variables that are related to a defined variable using a threshold T.
#'The parameter t is used to calculate T: t=1 means that every variable with higher probability that "by chance" is identified
#'as "important". t=2 means the probability has to be twice, etc.
#'Based on the threshold a vector is created containing the related variables.
#'
#' @param trees list of trees that was generated by getTreeranger function and layers, surrogate variables, and adjusted agreement values were added by addLayer and getSurrogates functions
#' @param variable variable name (string) for which related variable should be searched for (has to be contained in allvariables)
#' @param allvariables vector of all variable names (strings)
#' @param t variable to calculate threshold. Default is 5.
#'
#' @return a list containing:
#' \itemize{
#' \item variable: the variable to which relations are investigated
#' \item surr.res: vector with mean adjusted agreement values
#' \item threshold: the threshold used to select related variables
#' \item var: vector of related variables
#' }
#' @examples
#' # read data
#' data("SMD_example_data")
#'
#' \donttest{
#' ###### use result of SMD variable importance
#' # select variables with smd variable importance
#' res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10)
#' # investigate variable relations
#' rel.X2=var.relations(trees=res$trees,variable="X2",allvariables=names(res$info$depth),t=5)
#' rel.X2$var
#'
#' ###### use data
#'  # get trees and variable names
#'  x=SMD_example_data[,2:ncol(SMD_example_data)]
#'  y=SMD_example_data[,1]
#'  allvariables=colnames(x)# extract variables names
#'  nvar=length(allvariables)   # count number of variables
#'  RF=ranger::ranger(data=SMD_example_data,dependent.variable.name="y",num.trees=100,keep.inbag = TRUE,mtry=floor(nvar^(3/4)))
#'    trees=getTreeranger(RF=RF,ntree=100)
#'  trees.lay=addLayer(trees)
#'  trees.surr=addSurrogates(RF=RF,trees=trees.lay,s=10,Xdata=x)
#'
#'  # investigate variable relations
#'  rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
#'  rel.X2$var
#' }
#'
#' @export
var.relations = function(trees,variable,allvariables,t=5) {
if (variable %in% variables){
# count surrogates
s=count.surrogates(trees)
results.meanAdjAgree=meanAdjAgree(trees,variable,allvariables,t=t,s$s.a)
}
else {
stop("allvariables do not contain the chosen variable")
}
surr.var=results.meanAdjAgree$surr.var
surr.var=surr.var[-which(is.na(surr.var))]
var=names(surr.var[surr.var==1])
return(list(variable=results.meanAdjAgree$variable, surr.res=results.meanAdjAgree$surr.res,threshold=results.meanAdjAgree$threshold, var=var))
}
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
#' Investigate variable relations of a specific variable with mean adjusted agreement
#'
#'This function uses the parameter adjusted agreement to select variables that are related to a defined variable using a threshold T.
#'The parameter t is used to calculate T: t=1 means that every variable with higher probability that "by chance" is identified
#'as "important". t=2 means the probability has to be twice, etc.
#'Based on the threshold a vector is created containing the related variables.
#'
#' @param trees list of trees that was generated by getTreeranger function and layers, surrogate variables, and adjusted agreement values were added by addLayer and getSurrogates functions
#' @param variable variable name (string) for which related variable should be searched for (has to be contained in allvariables)
#' @param allvariables vector of all variable names (strings)
#' @param t variable to calculate threshold. Default is 5.
#'
#' @return a list containing:
#' \itemize{
#' \item variable: the variable to which relations are investigated
#' \item surr.res: vector with mean adjusted agreement values
#' \item threshold: the threshold used to select related variables
#' \item var: vector of related variables
#' }
#' @examples
#' # read data
#' data("SMD_example_data")
#'
#' \donttest{
#' ###### use result of SMD variable importance
#' # select variables with smd variable importance
#' res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=10)
#' # investigate variable relations
#' rel.X2=var.relations(trees=res$trees,variable="X2",allvariables=names(res$info$depth),t=5)
#' rel.X2$var
#'
#' ###### use data
#'  # get trees and variable names
#'  x=SMD_example_data[,2:ncol(SMD_example_data)]
#'  y=SMD_example_data[,1]
#'  allvariables=colnames(x)# extract variables names
#'  nvar=length(allvariables)   # count number of variables
#'  RF=ranger::ranger(data=SMD_example_data,dependent.variable.name="y",num.trees=100,keep.inbag = TRUE,mtry=floor(nvar^(3/4)))
#'    trees=getTreeranger(RF=RF,ntree=100)
#'  trees.lay=addLayer(trees)
#'  trees.surr=addSurrogates(RF=RF,trees=trees.lay,s=10,Xdata=x)
#'
#'  # investigate variable relations
#'  rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
#'  rel.X2$var
#' }
#'
#' @export
var.relations = function(trees,variable,allvariables,t=5) {
if (variable %in% allvariables){
# count surrogates
s=count.surrogates(trees)
results.meanAdjAgree=meanAdjAgree(trees,variable,allvariables,t=t,s$s.a)
}
else {
stop("allvariables do not contain the chosen variable")
}
surr.var=results.meanAdjAgree$surr.var
surr.var=surr.var[-which(is.na(surr.var))]
var=names(surr.var[surr.var==1])
return(list(variable=results.meanAdjAgree$variable, surr.res=results.meanAdjAgree$surr.res,threshold=results.meanAdjAgree$threshold, var=var))
}
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
rel.X2$var
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=100)
rel.X2$var
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=50)
rel.X2$var
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=20)
rel.X2$var
devtools::document()
library(SurrogateMinimalDepth)
data("SMD_example_data")
x=SMD_example_data[,2:ncol(SMD_example_data)]
y=SMD_example_data[,1]
allvariables=colnames(x)# extract variables names
nvar=length(allvariables)   # count number of variables
RF=ranger::ranger(data=SMD_example_data,dependent.variable.name="y",num.trees=100,keep.inbag = TRUE,mtry=floor(nvar^(3/4)))
trees=getTreeranger(RF=RF,ntree=100)
trees.lay=addLayer(trees)
trees.surr=addSurrogates(RF=RF,trees=trees.lay,s=10,Xdata=x)
# investigate variable relations
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=10)
rel.X2$var
# investigate variable relations
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=20)
rel.X2$var
# investigate variable relations
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=40)
rel.X2$var
# investigate variable relations
rel.X2=var.relations(trees=trees.surr,variable="X2",allvariables=allvariables,t=30)
rel.X2$var
# read data
data("SMD_example_data")
# select variables
res = var.select.md(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1])
res$var
# read data
data("SMD_example_data")
# select variables
res = var.select.md(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1])
res$var
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1])
res$var
# read data
data("SMD_example_data")
# select variables
res = var.select.smd(x=SMD_example_data[,2:ncol(SMD_example_data)],y=SMD_example_data[,1],s=5)
res$var
rel.X2=var.relations(trees=res$trees,variable="X2",allvariables=names(res$info$depth),t=5)
rel.X2$var
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
s = 10
ntree = 100
type = "classification"
mtry = NULL
min.node.size = 1
num.p = 200
num.threads= NULL
## set global parameters
if (is.null(mtry)) {
mtry = floor(nvar^(3/4))
}
variables = colnames(x)# extract variables names
nvar = length(variables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor(nvar^(3/4))
}
if (num.p > ncol(x)) {
message("More permuted variables than original variables are needed. They are now partially based on the same original variables")
var.perm = sample(c(1:ncol(x)),num.p, replace = TRUE)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
} else {
var.perm = sample(c(1:ncol(x)),num.p)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
}
data = data.frame(y, x, x_perm)
#' @keywords internal
permute.variable=function(i=1,x){
var.perm = sample(x[,i],nrow(x))
return(var.perm)
}
if (num.p > ncol(x)) {
message("More permuted variables than original variables are needed. They are now partially based on the same original variables")
var.perm = sample(c(1:ncol(x)),num.p, replace = TRUE)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
} else {
var.perm = sample(c(1:ncol(x)),num.p)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
}
data = data.frame(y, x, x_perm)
test = data[,-1]
View(test)
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = variables)
library(SurrogateMinimalDepth)
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = variables)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, importance ="impurity_corrected")
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = variables)
rel = var.relations(forest = forest,variables = variables, candidates = variables)
adj.agree[which(is.na(adj.agree))] = 1
sgi = rowSums(t(t(adj.agree) * RF$variable.importance))
colnames(data[,-1])
rel = var.relations(forest = forest,variables = colnames(data[,-1]), candidates = colnames(data[,-1]))
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# determine variable relations
rel = var.relations(forest = forest,variables = colnames(data[,-1]), candidates = colnames(data[,-1]))
adj.agree[which(is.na(adj.agree))] = 1
sgi = rowSums(t(t(adj.agree) * RF$variable.importance))
rel$surr.res
adj.agree = rel$surr.res
adj.agree[which(is.na(adj.agree))] = 1
sgi = rowSums(t(t(adj.agree) * RF$variable.importance))
sgisgi
sgi
vimp = sgi[1:length(variables)]
names(vimp) = variables
vimp
library(ranger)
?numSmaller
numSmaller
ranger:::numSmaller
importance_pvalues()
importance_pvalues
vimp = sgi[length(variables)+1:length(mir)]
adj.agree = rel$surr.res
adj.agree[which(is.na(adj.agree))] = 1
mir = rowSums(t(t(adj.agree) * RF$variable.importance))
vimp = sgi[length(variables)+1:length(mir)]
vimp
(length(variables) + 1)
length(mir)
vimp = sgi[(length(variables) + 1):length(mir)]
mir[1:length(variables)
]
mir[1:length(variables)]
# compute p-values using numSmaller function from ranger
pval <- 1 - ranger:::numSmaller(mir[1:length(variables)], vimp) / length(vimp)
names(pval) = variables
pval
?var.select.smd
selected = as.numeric(pval < p.t)
names(selected) = names(pval)
p.t = 0.05
selected = as.numeric(pval < p.t)
names(selected) = names(pval)
selected
MIR = mir[1:length(variables)]
MIR
info$selected == 1
info = list(MIR = mir[1:length(variables)],
pval = pval,
selected =selected,
parameters = list(s = s, type = type, mtry = mtry, p.t = p.t))
info$selected == 1
names(info$selected == 1)
info$selected == 1
info$selected == 1
names(info$selected[info$selected == 1])
library(SurrogateMinimalDepth)
library(SurrogateMinimalDepth)
devtools::document()
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 500)
res$var
res$info$MIR
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100,num.p = 400)
res$var
res$info$MIR
res$info$pvalue
library(SurrogateMinimalDepth)
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 100, ntree = 100)
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 5, ntree = 100)
res$var
res$info$MIR
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 5, ntree = 500)
res$var
res$info$MIR
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 50, ntree = 100)
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 50, ntree = 500)
res$var
library(SurrogateMinimalDepth)
?var.select.mir
devtools::document()
library(SurrogateMinimalDepth)
?var.select.mir
library(SurrogateMinimalDepth)
library(SurrogateMinimalDepth)
nvar = 1000
num.p = 500
mtry = floor((nvar+num.p)^(3/4))
mtry = "sqrt"
(mtry == "sqrt")
if (mtry == "sqrt") {
mtry = sqrt(nvar + num.p)
}
"0.5"
(mtry == "0.5")
mtry = "0.5"
(mtry == "0.5")
if (mtry == "0.5") {
mtry = floor(0.5*(nvar + num.p))
}
library(PathwayGuidedRF)
mtry= "^3/4"
if (mtry == "^3/4") {
mtry = floor((nvar + num.p)^(3/4))
}
devtools::document()
library(SurrogateMinimalDepth)
?var.select.mir
devtools::document()
library(SurrogateMinimalDepth)
?var.select.mir
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
s = 10
ntree = 100
type = "classification"
mtry = NULL
min.node.size = 1
num.p = 200
num.threads= NULL
var.perm = sample(c(1:ncol(x)),num.p)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
variables = colnames(x)# extract variables names
nvar = length(variables)   # count number of variables
var.perm = sample(c(1:ncol(x)),num.p)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
#'
#' This is an internal function
#'
#' @keywords internal
permute.variable=function(i=1,x){
var.perm = sample(x[,i],nrow(x))
return(var.perm)
}
var.perm = sample(c(1:ncol(x)),num.p)
x_perm = sapply(var.perm,permute.variable,x=x)
colnames(x_perm) = paste(variables[var.perm],"_perm", sep = "")
data = data.frame(y, x, x_perm)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, importance ="impurity_corrected")
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
library(SurrogateMinimalDepth)
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# determine variable relations
rel = var.relations(forest = forest,variables = colnames(data[,-1]), candidates = colnames(data[,-1]))
adj.agree = rel$surr.res
adj.agree[which(is.na(adj.agree))] = 1
mir = rowSums(t(t(adj.agree) * RF$variable.importance))
vimp = sgi[(length(variables) + 1):length(mir)]
mir
vimp = mir[(length(variables) + 1):length(mir)]
vimp
# compute p-values using numSmaller function from ranger
pval <- 1 - ranger:::numSmaller(mir[1:length(variables)], vimp) / length(vimp)
names(pval) = variables
selected = as.numeric(pval < p.t)
names(selected) = names(pval)
p.t = 0.05
# compute p-values using numSmaller function from ranger
pval <- 1 - ranger:::numSmaller(mir[1:length(variables)], vimp) / length(vimp)
names(pval) = variables
selected = as.numeric(pval < p.t)
names(selected) = names(pval)
info = list(MIR = mir[1:length(variables)],
pvalue = pval,
selected =selected,
parameters = list(s = s, type = type, mtry = mtry, p.t = p.t))
library(SurrogateMinimalDepth)
?var.relations
