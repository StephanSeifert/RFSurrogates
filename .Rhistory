case.weights = NULL
corr.rel = TRUE
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
if (create.forest) {
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = data.frame(lapply(1:ncol(x),permute.variable,x=x))
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry, min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
data_perm$status = status
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
}
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
}
create.forest = TRUE
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
if (create.forest) {
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = data.frame(lapply(1:ncol(x),permute.variable,x=x))
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry, min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
data_perm$status = status
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
}
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
}
#' permute.variable
#'
#' This is an internal function
#'
#' @keywords internal
permute.variable=function(i=1,x){
var.perm = sample(x[,i],nrow(x))
return(var.perm)
}
#' p.relation
#'
#' This is an internal function
#'
#' @keywords internal
p.relation = function(l = 1,
null.rel,
adj.agree.corr,
candidates,
variables) {
relations = adj.agree.corr[l,]
pval <- 1 - ranger:::numSmaller(relations, null.rel) / length(null.rel)
names(pval) = candidates
pval[variables[l]] = NA
return(pval)
}
#' select.related
#'
#' This is an internal function
#'
#' @keywords internal
select.related = function(m=1,
rel.p,
p.t) {
rel.var = rel.p[[m]]
names(which(rel.var <= p.t))
}
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
if (create.forest) {
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = data.frame(lapply(1:ncol(x),permute.variable,x=x))
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry, min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
data_perm$status = status
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
}
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
}
if (!create.forest) {
if (is.null(forest)) {
stop("set create.forest to TRUE or analyze an existing random forest specified by parameter forest")
}
}
if (all(candidates %in% allvariables)) {
if (all(variables %in% allvariables)) {
# count surrogates
s = count.surrogates(forest$trees)
rel = meanAdjAgree(forest$trees, variables = allvariables, allvariables = allvariables, candidates = allvariables,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
allvariables_perm = colnames(x_perm)
rel_perm = meanAdjAgree(forest_perm$trees, variables = allvariables_perm , allvariables = allvariables_perm , candidates = allvariables_perm,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
} else {
stop("allvariables do not contain the chosen variables")
}
} else {
stop("allvariables do not contain the candidate variables")
}
candidates = colnames(x)[1:100]
variables = c("X1","X7")
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
if (create.forest) {
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = data.frame(lapply(1:ncol(x),permute.variable,x=x))
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry, min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
data_perm$status = status
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
}
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
}
if (!create.forest) {
if (is.null(forest)) {
stop("set create.forest to TRUE or analyze an existing random forest specified by parameter forest")
}
}
if (all(candidates %in% allvariables)) {
if (all(variables %in% allvariables)) {
# count surrogates
s = count.surrogates(forest$trees)
rel = meanAdjAgree(forest$trees, variables = allvariables, allvariables = allvariables, candidates = allvariables,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
allvariables_perm = colnames(x_perm)
rel_perm = meanAdjAgree(forest_perm$trees, variables = allvariables_perm , allvariables = allvariables_perm , candidates = allvariables_perm,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
} else {
stop("allvariables do not contain the chosen variables")
}
} else {
stop("allvariables do not contain the candidate variables")
}
adj.agree = rel$surr.res
adj.agree.perm = rel_perm$surr.res
diag(adj.agree) = diag(adj.agree.perm) = 1
if(anyNA(adj.agree)) {
no.na = length(which(rowSums(is.na(adj.agree)) != 0 ))
warning(paste0("Relations for ", no.na, " original variables were not calculated because they were never used as a primary split.
Affected relations are set to 0. "))
adj.agree[which(is.na(adj.agree))] = 0
}
if(anyNA(adj.agree.perm)) {
no.na = length(which(rowSums(is.na(adj.agree.perm)) != 0 ))
warning(paste0("Relations for ", no.na, " permuted variables were not calculated because they were not used as a primary split.
Affected relations are set to 0. "))
adj.agree.perm[which(is.na(adj.agree.perm))] = 0
}
adj.agree.corr = adj.agree - adj.agree.perm[1:nvar,1:nvar]
diag(adj.agree.corr) =  diag(adj.agree) = diag(adj.agree.perm) =  NA
adj.agree.corr.var = adj.agree.corr[variables,candidates]
null.rel.plus = as.vector(adj.agree.perm)
null.rel.plus = null.rel[!is.na(null.rel)]
null.rel.plus = as.vector(adj.agree.perm)
null.rel.plus = null.rel.plus[!is.na(null.rel.plus)]
null.rel.plus
m1 = null.rel.plus[adj.agree.1 > 0]
m1 = null.rel.plus[null.rel.plus > 0]
m2 = null.rel.plus[null.rel.plus == 0]
m1
m2
m1 = null.rel.plus[null.rel.plus > 0]
m2 = null.rel.plus[null.rel.plus == 0]
null.rel = c(m1, -m1, m2)
plot(null.rel)
hist(null.rel)
plot(density(null.rel))
?var.relations.mfi
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7","X3"), candidates = colnames(x)[1:100])
res$var.rel[[3]]
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7","X3"), candidates = colnames(x)[1:100],method = "permutation")
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7","X3"), candidates = colnames(x)[1:100],method = "permutation")
res$var.rel[[3]]
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 1000, variables = c("X1","X7","X3"), candidates = colnames(x)[1:100],method = "permutation")
res$var.rel[[3]]
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 1000, variables = c("X1","X7","X3"), candidates = colnames(x)[1:100],method = "janitza")
res$var.rel[[3]]
RF$variable.importance
?var.select.mir
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
res$info$AIR
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10, method = "permutation")
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10, method.sel = "permutation")
res$var
