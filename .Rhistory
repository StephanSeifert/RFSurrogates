<<<<<<< HEAD
=======
<<<<<<< HEAD
=======
var.1 = c(rep("A",25),rep("B",25),rep("C",25),rep("D",25))
var.2 = c(rep("C",25),rep("A",25),rep("D",25),rep("B",25))
#erste variable
var.1[c(9,13,17,24)] = "C"
var.1[c(3,4)] = "D"
var.1[c(6)] = "B"
var.2[c(9,13,17,24)] = "D"
var.2[c(3,4)] = "B"
var.2[c(6)] = "A"
#zweite variable
var.1[c(27,33,38,41,44)] = "C"
var.1[30] = "D"
var.1[c(35,48)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "B"
var.2[c(35,48)] = "C"
#dritte variable
var.1[c(59,63,67,74)] = "A"
var.1[c(53,54)] = "B"
var.1[56] = "D"
var.2[c(59,63,67,74)] = "C"
var.2[c(53,54)] = "A"
var.2[56] = "B"
#vierte variable
var.1[c(77,83,88,91,94)] = "C"
var.1[80] = "B"
var.1[c(85,98)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "A"
var.2[c(35,48)] = "C"
testdata = cbind(var.1,var.2,var.1,restvar)
rownames(testdata) = paste0("sample_",c(1:100))
colnames(testdata) = paste0("variable_",c(1:20))
ntree = 50
RF = ranger(x=testdata, y=class, classification = TRUE, num.trees = ntree, respect.unordered.factors = "partition")
trees = getTreeranger(RF = RF,ntree = ntree)
set.seed(42)
res = var.relations(x = testdata,
y = class,
s = 9,
ntree = 1000,
t = 5,
create.forest = TRUE,
candidates = colnames(testdata),
variables = colnames(testdata),
type = "classification")
res$surr.res
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
variables = colnames(x)    # extract variables names
nvar = length(variables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*nvar)
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
>>>>>>> SMD_0.2.1_LCJ_2
}
s
type
y = as.factor(y)
x_perm = sapply(1:ncol(x),permute.variable,x=x)
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
View(x_perm)
select.rel
f = ceiling(25 / (ncol(x))) # f determines how often the variables are permuted (only more than 1 time when less than 25 variables are present)
( ncol(x) < min.var.p)
library(SurrogateMinimalDepth)
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = colnames(x)[1:5], candidates = colnames(x), type = "classification", method = "permutation")
res
library(SurrogateMinimalDepth)
devtools::document()
devtools::document()
rm(list = c("count.surrogates", "p.relation", "permute.variable", "scount", "select.related", "var.relations.mfi"))
devtools::document()
library(SurrogateMinimalDepth)
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = colnames(x)[1:5], candidates = colnames(x), type = "classification", method = "permutation")
res
f = ceiling(25 / (ncol(x))) # f determines how often the variables are permuted (only more than 1 time when less than 25 variables are present)
( ncol(x) < min.var.p)
min.var.p = 200
( ncol(x) < min.var.p)
ncol(x)
x_perm2 = matrix(rep(sapply(1:ncol(x),permute.variable,x=x), (f-1)),nrow = nrow(x), ncol= ncol(x) * (f-1))
#' Investigate variable relations of a specific variable with mutual forest impact (corrected mean adjusted agreement).
#'
#'This function corrects the mean adjusted agreement by a permutation approach and generates the relation parameter mutual forest impact. Subsequently p-values are determined and related variables are selected.
#'
#' @param variables variable names (string) for which related variables should be searched for (has to be contained in allvariables)
#' @param candidates vector of variable names (strings) that are candidates to be related to the variables (has to be contained in allvariables)
#' @param p.t p.value threshold for selection of related variables. Default is 0.01.
#' @param min.var.p minimum number of permuted variables used to determine p-value for variable selection of important variables. Default is 200.
#' @param select.rel set False if only relations should be calculated and no related variables should be selected.
#' @param method Method  to  compute  p-values.   Use  "janitza"  for  the  method  by  Janitza  et  al. (2016) or "permutation" to utilize importance values of permuted variables.
#' @param num.threads number of threads used for determination of relations. Default is number of CPUs available.
#' @inheritParams var.select.smd
#'
#' @return a list containing:
#' \itemize{
#' \item variables: the variables to which relations are investigated.
#' \item surr.res: a matrix with the mutual forest impact values with variables in rows and candidates in columns.
#' \item p.rel: a list with the obtained p-values for the relation analysis of each variable.
#' \item var.rel: a list with vectors of related variables for each variable.
#' \item ranger: ranger objects.
#' \item method: Method  to  compute  p-values: "janitza" or "permutation".
#' \item p.t: p.value threshold for selection of related variables
#'
#'
#' }
#' @examples
#' # read data
#' data("SMD_example_data")
#' x = SMD_example_data[,2:ncol(SMD_example_data)]
#' y = SMD_example_data[,1]
#' \donttest{
#' # calculate variable relations
#' set.seed(42)
#' res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
#' res$var.rel[[1]]
#' }
#'
#' @export
var.relations.mfi = function(x = NULL, y = NULL, ntree = 500, type = "regression", s = NULL, mtry = NULL, min.node.size = 1,
num.threads = NULL, status = NULL, save.ranger = FALSE, create.forest = TRUE, forest = NULL,
save.memory = FALSE, case.weights = NULL, min.var.p = 200,
variables, candidates, p.t = 0.01, select.rel = TRUE, method = "janitza") {
if (create.forest) {
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = sapply(1:ncol(x),permute.variable,x=x)
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
if (select.rel & method == "permutation") {
f = ceiling(25 / (ncol(x))) # f determines how often the variables are permuted (only more than 1 time when less than 25 variables are present)
if ( ncol(x) < min.var.p) {
message("More permuted variables than original variables are needed so they are permuted multiple times.")
x_perm2 = matrix(rep(sapply(1:ncol(x),permute.variable,x=x), (f-1)),nrow = nrow(x), ncol= ncol(x) * (f-1))
colnames(x_perm2) = rep(paste(variables,"_perm", sep = ""),(f-1))
x_perm = cbind(x_perm,x_perm2)
}
}
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
if (type == "survival") {
if (is.null(status)) {
stop("a status variables has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry, min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, dependent.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, dependent.variable.name = "status", save.memory = save.memory,
case.weights = case.weights, respect.unordered.factors = "partition")
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights)
}
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
}
if (!create.forest) {
if (is.null(forest)) {
stop("set create.forest to TRUE or analyze an existing random forest specified by parameter forest")
}
}
if (all(candidates %in% allvariables)) {
if (all(variables %in% allvariables)) {
# count surrogates
s = count.surrogates(forest$trees)
rel = meanAdjAgree(forest$trees, variables = allvariables, allvariables = allvariables, candidates = allvariables,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
allvariables_perm = colnames(x_perm)
rel_perm = meanAdjAgree(forest_perm$trees, variables = allvariables_perm , allvariables = allvariables_perm , candidates = allvariables_perm,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
} else {
stop("allvariables do not contain the chosen variables")
}
} else {
stop("allvariables do not contain the candidate variables")
}
adj.agree = rel$surr.res
adj.agree.perm = rel_perm$surr.res
diag(adj.agree) = diag(adj.agree.perm) = 1
if(anyNA(adj.agree)) {
no.na = length(which(is.na(adj.agree)))
warning(paste0(no.na," relations were not calculated for the original variables because not all variables are used in a primary split.
Affected relations are set to 0. "))
adj.agree[which(is.na(adj.agree))] = 0
}
if(anyNA(adj.agree.perm)) {
no.na = length(which(is.na(adj.agree.perm)))
warning(paste0(no.na," relations were not calculated for the permuted variables because not all variables are used in a primary split.
Affected relations are set to 0. "))
adj.agree.perm[which(is.na(adj.agree.perm))] = 0
}
adj.agree.corr = adj.agree - adj.agree.perm[1:nvar,1:nvar]
diag(adj.agree.corr) =  diag(adj.agree) = diag(adj.agree.perm) =  NA
adj.agree.corr.var = adj.agree.corr[variables,candidates]
if (select.rel) {
if (method == "janitza") {
adj.agree.1 = adj.agree.corr
diag(adj.agree.1) = 1
## Mirrored VIMP (# This part is taken from ranger function)
m1 = adj.agree.1[adj.agree.1 < 0]
m2 = adj.agree.1[adj.agree.1 == 0]
null.rel = c(m1, -m1, m2)
if (length(m1) == 0) {
stop("No negative importance values found for selection of related variables. Consider the 'permutation' approach.")
}
if (length(m1) < 100) {
warning("Only few negative importance values found for selection of related variables, inaccurate p-values. Consider the 'permutation' approach.")
}
rel.p = lapply(1:length(variables),p.relation,
null.rel = null.rel,
adj.agree.corr = adj.agree.corr.var,
candidates = candidates,
variables = variables)
sel.rel = lapply(1:length(variables),select.related,
rel.p,
p.t)
names(rel.p) = names(sel.rel) = variables
}
if (method == "permutation") {
null.rel = as.vector(adj.agree.perm)
null.rel = null.rel[!is.na(null.rel)]
rel.p = lapply(1:length(variables),p.relation,
null.rel = null.rel,
adj.agree.corr = adj.agree.corr.var,
candidates = candidates,
variables = variables)
sel.rel = lapply(1:length(variables),select.related,
rel.p,
p.t)
names(rel.p) = names(sel.rel) = variables
}
if (save.ranger) {
return(list(variables = variables, surr.res = adj.agree.corr.var,
p.rel = rel.p, var.rel = sel.rel, ranger = list(RF = RF,RF_perm = RF_perm), method = method, p.t = p.t))
} else {
return(list(variables = variables, surr.res = adj.agree.corr.var, p.rel = rel.p, var.rel = sel.rel, method = method, p.t = p.t))
}
} else {
if (save.ranger) {
return(list(variables = variables, surr.res = adj.agree.corr.var, ranger = list(RF = RF,RF_perm = RF_perm)))
} else {
return(list(variables = variables, surr.res = adj.agree.corr.var))
}
}
}
#' permute.variable
#'
#' This is an internal function
#'
#' @keywords internal
<<<<<<< HEAD
permute.variable=function(i=1,x){
var.perm = sample(x[,i],nrow(x))
return(var.perm)
}
#' p.relation
=======
>>>>>>> c43f67775309b4b7c912faaf5b00fc3d7da291be
getsingletree=function(RF,k=1){
# here we use the treeInfo function of the ranger package to create extract the trees, in an earlier version this was done with a self implemented function
tree.ranger = ranger::treeInfo(RF,tree = k)
ktree=data.frame(as.numeric(tree.ranger$nodeID+1),
as.numeric(tree.ranger$leftChild+1),
as.numeric(tree.ranger$rightChild+1),
as.numeric(tree.ranger$splitvarID+1),
tree.ranger$splitval,
tree.ranger$terminal)
if (is.factor(ktree[,5])) {
ktree[,5] = as.character(levels(ktree[,5] ))[ktree[,5]]
}
ktree[,6] = as.numeric(ktree[,6] == FALSE)
for (i in 2:4) {
ktree[,i][is.na(ktree[,i])] = 0
}
colnames(ktree)=c("nodeID","leftdaughter","rightdaughter","splitvariable","splitpoint","status")
return(ktree)
}
trees=lapply(1:ntree,getsingletree,RF=RF)
colnames(ktree)=c("nodeID","leftdaughter","rightdaughter","splitvariable","splitpoint","status")
View(trees)
trees[[1]]
#'Get a list of structured trees for ranger
>>>>>>> SMD_0.2.1_LCJ_2
#'
#' This is an internal function
#'
#' @keywords internal
p.relation = function(l = 1,
null.rel,
adj.agree.corr,
candidates,
variables) {
relations = adj.agree.corr[l,]
pval <- 1 - ranger:::numSmaller(relations, null.rel) / length(null.rel)
names(pval) = candidates
pval[variables[l]] = NA
return(pval)
}
#' select.related
#'
#' This is an internal function
#'
#' @keywords internal
select.related = function(m=1,
rel.p,
p.t) {
rel.var = rel.p[[m]]
names(which(rel.var <= p.t))
}
x_perm2 = matrix(rep(sapply(1:ncol(x),permute.variable,x=x), (f-1)),nrow = nrow(x), ncol= ncol(x) * (f-1))
x_perm2
colnames(x_perm2) = rep(paste(variables,"_perm", sep = ""),(f-1))
colnames(x_perm2)
rep(paste(variables,"_perm", sep = ""),(f-1))
f
variables
variables
x_perm2
View(x_perm2)
ceiling(25 / (ncol(x)))
ncol(x)
x_perm2 = matrix(rep(sapply(1:ncol(x),permute.variable,x=x), (f-1)),nrow = nrow(x), ncol= ncol(x) * (f-1))
colnames(x_perm2) = rep(paste(variables,"_perm", sep = ""),(f-1))
colnames(x_perm2) = rep(paste(allvariables,"_perm", sep = ""),(f-1))
x_perm = cbind(x_perm,x_perm2)
library(SurrogateMinimalDepth)
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = colnames(x)[1:5], candidates = colnames(x), type = "classification", method = "permutation")
res
library(SurrogateMinimalDepth)
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = colnames(x)[1:5], candidates = colnames(x), type = "classification", method = "permutation")
res
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
# create shadow variables to correct the relation
x_perm = sapply(1:ncol(x),permute.variable,x=x)
colnames(x_perm) = paste(allvariables,"_perm", sep = "")
if (select.rel & method == "permutation") {
f = ceiling(25 / (ncol(x))) # f determines how often the variables are permuted (only more than 1 time when less than 25 variables are present)
if ( ncol(x) < min.var.p) {
message("More permuted variables than original variables are needed so they are permuted multiple times.")
x_perm2 = matrix(rep(sapply(1:ncol(x),permute.variable,x=x), (f-1)),nrow = nrow(x), ncol= ncol(x) * (f-1))
colnames(x_perm2) = rep(paste(allvariables,"_perm", sep = ""),(f-1))
x_perm = cbind(x_perm,x_perm2)
}
}
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights)
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
trees.surr
candidates %in% allvariables
all(variables %in% allvariables
)
s = count.surrogates(forest$trees)
rel = meanAdjAgree(forest$trees, variables = allvariables, allvariables = allvariables, candidates = allvariables,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
allvariables_perm = colnames(x_perm)
allvariables_perm
rel_perm = meanAdjAgree(forest_perm$trees, variables = allvariables_perm , allvariables = allvariables_perm , candidates = allvariables_perm,
t = t, s$s.a, select.var = FALSE, num.threads = num.threads)
adj.agree = rel$surr.res
adj.agree.perm = rel_perm$surr.res
diag(adj.agree) = diag(adj.agree.perm) = 1
anyNA(adj.agree)
adj.agree
adj.agree.corr = adj.agree - adj.agree.perm[1:nvar,1:nvar]
adj.agree.corr
diag(adj.agree.corr) =  diag(adj.agree) = diag(adj.agree.perm) =  NA
adj.agree.corr.var = adj.agree.corr[variables,candidates]
null.rel = as.vector(adj.agree.perm)
null.rel = null.rel[!is.na(null.rel)]
rel.p = lapply(1:length(variables),p.relation,
null.rel = null.rel,
adj.agree.corr = adj.agree.corr.var,
candidates = candidates,
variables = variables)
rel.p
sel.rel = lapply(1:length(variables),select.related,
rel.p,
p.t)
sel.rel
f = ceiling(min.var.p / (ncol(x))) # f determines how often the variables are permuted (only more than 1 time when less than 25 variables are present)
f
message("More permuted variables than original variables are needed so they are permuted multiple times.")
x_perm2 = matrix(rep(sapply(1:ncol(x),permute.variable,x=x), (f-1)),nrow = nrow(x), ncol= ncol(x) * (f-1))
colnames(x_perm2) = rep(paste(allvariables,"_perm", sep = ""),(f-1))
x_perm = cbind(x_perm,x_perm2)
View(x_perm)
data = data.frame(y, x)
data_perm = data.frame(y, x_perm)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
RF_perm = ranger::ranger(data = data_perm,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
rm(trees.lay)
forest = list(trees = trees.surr, allvariables = colnames(data[,-1]))
# do the same for the permutation forrest
trees_perm = getTreeranger(RF = RF_perm,ntree = ntree)
trees.lay_perm = addLayer(trees_perm)
rm(trees_perm)
###AddSurrogates###
trees.surr_perm = addSurrogates(RF = RF_perm,trees = trees.lay_perm,s = s,Xdata = data_perm[,-1], num.threads = num.threads)
rm(trees.lay_perm)
forest_perm = list(trees = trees.surr_perm, allvariables = colnames(data_perm[,-1]))
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = data[,-1], num.threads = num.threads)
library(SurrogateMinimalDepth)
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = colnames(x)[1:5], candidates = colnames(x), type = "classification", method = "permutation")
res
?var.select.mgi
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10)
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10, method = "permutation")
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10, method.sel = "permutation")
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10)
res$var
x_perm
allvariables
candidates = allvariables
variables = allvariables
allvariables = colnames(x_perm)# extract variables names
library(SurrogateMinimalDepth)
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10, method.sel = "permutation")
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10, method.sel = "permutation")
res$var
<<<<<<< HEAD
=======
>>>>>>> Stashed changes
library(devtools)
pacman::p_load(devtools)
devtools::check()
<<<<<<< HEAD
pacman::p_load(devtools, SurrogateMinimalDepth, labelled)
# for removing attr package labelled is neccesary
install_github("StephanSeifert/SurrogateMinimalDepth", ref = "SMD_0.2.1_LCJ")
pacman::p_load(devtools, SurrogateMinimalDepth, labelled)
=======
library("R.utils")
test = loadObject(file = "/home/stephan/Projekte/mutualginiimpurity/subprojects/03_ComparisonStudy_SimStudy3/data/gene_expression_array/simulation/classification/effects_-2_-1_-0.5_0.5_1_2/samples_200/causal.var_150/results/ntree_ 5000 _mtry_p34/mir/par_500_0.01/results_rep_1_data_set_1.RData")
>>>>>>> SMD_0.2.1_LCJ_2
library(SurrogateMinimalDepth)
library(SurrogateMinimalDepth)
<<<<<<< HEAD
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 10, method.sel = "permutation")
res$var
res
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 100, method.sel = "permutation")
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 10, ntree = 100)
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 5, ntree = 10, method.sel = "permutation")
=======
?var.select.smd
# read data
>>>>>>> c43f67775309b4b7c912faaf5b00fc3d7da291be
data("SMD_example_data")
dim(SMD_example_data)
head(SMD_example_data[, 1:5])
set.seed(42)
res.smd = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)],
y = SMD_example_data[,1], s= 10, ntree = 10)
res2.smd = var.select.smd(x = testdata[,1:ncol(testdata)],
y = testdata[,1], s = 10, ntree = 10, type = "classification")
library("SurrogateMinimalDepth")
library("ranger")
data("SMD_example_data")
class = c(rep(1,50),rep(0,50))
restvar = SMD_example_data[,184:200]
var.1 = c(rep("A",25),rep("B",25),rep("C",25),rep("D",25))
var.2 = c(rep("C",25),rep("A",25),rep("D",25),rep("B",25))
#erste variable
var.1[c(9,13,17,24)] = "C"
var.1[c(3,4)] = "D"
var.1[c(6)] = "B"
var.2[c(9,13,17,24)] = "D"
var.2[c(3,4)] = "B"
var.2[c(6)] = "A"
#zweite variable
var.1[c(27,33,38,41,44)] = "C"
var.1[30] = "D"
var.1[c(35,48)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "B"
var.2[c(35,48)] = "C"
#dritte variable
var.1[c(59,63,67,74)] = "A"
var.1[c(53,54)] = "B"
var.1[56] = "D"
var.2[c(59,63,67,74)] = "C"
var.2[c(53,54)] = "A"
var.2[56] = "B"
#vierte variable
var.1[c(77,83,88,91,94)] = "C"
var.1[80] = "B"
var.1[c(85,98)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "A"
var.2[c(35,48)] = "C"
testdata = cbind(var.1,var.2,var.1,restvar)
rownames(testdata) = paste0("sample_",c(1:100))
colnames(testdata) = paste0("variable_",c(1:20))
res2.smd = var.select.smd(x = testdata[,1:ncol(testdata)],
y = testdata[,1], s = 10, ntree = 10, type = "classification")
res.smd$var
res2.smd$var
testdata = cbind(var.1,var.1,var.1,restvar)
rownames(testdata) = paste0("sample_",c(1:100))
colnames(testdata) = paste0("variable_",c(1:20))
View(testdata)
res2.smd = var.select.smd(x = testdata[,1:ncol(testdata)],
y = testdata[,1], s = 10, ntree = 10, type = "classification")
pacman::p_load(devtools, SurrogateMinimalDepth, labelled)
# for removing attr package labelled is neccesary
install_github("StephanSeifert/SurrogateMinimalDepth", ref = "SMD_0.2.1_LCJ_2")
pacman::p_load(devtools, SurrogateMinimalDepth, labelled)
data("SMD_example_data")
dim(SMD_example_data)
head(SMD_example_data[, 1:5])
set.seed(42)
res.smd = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)],
y = SMD_example_data[,1], s= 10, ntree = 10)
res2.smd = var.select.smd(x = testdata[,1:ncol(testdata)],
y = testdata[,1], s = 10, ntree = 10, type = "classification")
data("SMD_example_data")
dim(SMD_example_data)
head(SMD_example_data[, 1:5])
set.seed(42)
<<<<<<< HEAD
res.smd = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)],
y = SMD_example_data[,1], s= 10, ntree = 10)
dyn.load("integrating2.so")
getSurrogates <- function(ncat, wt, X, controls, var, split) {
.Call("getSurrogates", ncat, wt, X, controls, var, split)
}
maxsur <- 10
sur_agree <- 0
wt <- rep(c(1), 100)
controls <- c(maxsur, sur_agree)
ncat2 <- c(4, 4, 4, rep(0L, 17))
cat_direction2 <- c(4L, -1L, -1L, 1L, -1L)
controls <- c(maxsur, sur_agree)
node <- c(3)
var <- c(1)
split_for_cat <- c(4L, -1L, -1L, 1L, -1L)
surPar_cat <-getSurrogates(ncat = as.integer(ncat2),
wt = as.numeric(wt),
X = as.matrix(testdata),
controls = as.integer(unlist(controls)),
var = as.integer(var),
split = as.numeric(split_for_cat))
surPar_cat
dyn.load("integrating2.so")
setwd("~/")
dyn.load("integrating2.so")
getSurrogates <- function(ncat, wt, X, controls, var, split) {
.Call("getSurrogates", ncat, wt, X, controls, var, split)
}
maxsur <- 10
sur_agree <- 0
wt <- rep(c(1), 100)
controls <- c(maxsur, sur_agree)
ncat2 <- c(4, 4, 4, rep(0L, 17))
cat_direction2 <- c(4L, -1L, -1L, 1L, -1L)
controls <- c(maxsur, sur_agree)
node <- c(3)
var <- c(1)
split_for_cat <- c(4L, -1L, -1L, 1L, -1L)
surPar_cat <-getSurrogates(ncat = as.integer(ncat2),
wt = as.numeric(wt),
X = as.matrix(testdata),
controls = as.integer(unlist(controls)),
var = as.integer(var),
split = as.numeric(split_for_cat))
data("SMD_example_data.RData")
class = c(rep(1,50),rep(0,50))
restvar = SMD_example_data[,184:200]
restvar3 = SMD_example_data[,184:186]
restvar4 = SMD_example_data[,187:190]
restvar8 = SMD_example_data[,184:191]
restvar9 = SMD_example_data[,192:200]
restvar13 = SMD_example_data[,188:200]
restvar16 = SMD_example_data[,185:200]
var.1 = c(rep(1,25),rep(2,25),rep(3,25),rep(4,25))
var.2 = c(rep(3,25),rep(1,25),rep(4,25),rep(2,25))
var.3 = c(rep(1,25),rep(2,25),rep(3,25),rep(4,25))
#erste variable
var.1[c(9,13,17,24)] = 3
var.1[c(3,4)] = 4
var.1[c(6)] = 2
var.2[c(9,13,17,24)] = 4
var.2[c(3,4)] = 2
var.2[c(6)] = 1
# difference between var.1 & var.3
var.3[c(9,13,17,24)] = 3
var.3[c(3,4)] = 3
var.3[c(6)] = 1
#zweite variable
var.1[c(27,33,38,41,44)] = 3
var.1[30] = 4
var.1[c(35,48)] = 1
var.2[c(27,33,38,41,44)] = 4
var.2[30] = 2
var.2[c(35,48)] = 3
var.3[c(27,33,38,41,44)] = 3
var.3[30] = 4
var.3[c(35,48)] = 1
#dritte variable
var.1[c(59,63,67,74)] = 1
var.1[c(53,54)] = 2
var.1[56] = 4
var.2[c(59,63,67,74)] = 3
var.2[c(53,54)] = 1
var.2[56] = 2
var.3[c(59,63,67,74)] = 1
var.3[c(53,54)] = 2
var.3[56] = 4
#vierte variable
var.1[c(77,83,88,91,94)] = 3
var.1[80] = 2
var.1[c(85,98)] = 1
var.2[c(27,33,38,41,44)] = 4
var.2[30] = 1
var.2[c(35,48)] = 3
var.3[c(77,83,88,91,94)] = 3
var.3[80] = 2
var.3[c(85,98)] = 1
testdata = cbind(var.1, var.1, var.1, restvar)
rownames(testdata) = paste0("sample_",c(1:100))
colnames(testdata) = paste0("variable_",c(1:20))
View(testdata)
dyn.load("integrating2.so")
getSurrogates <- function(ncat, wt, X, controls, var, split) {
.Call("getSurrogates", ncat, wt, X, controls, var, split)
}
maxsur <- 10
sur_agree <- 0
wt <- rep(c(1), 100)
controls <- c(maxsur, sur_agree)
ncat2 <- c(4, 4, 4, rep(0L, 17))
cat_direction2 <- c(4L, -1L, -1L, 1L, -1L)
controls <- c(maxsur, sur_agree)
node <- c(3)
var <- c(1)
split_for_cat <- c(4L, -1L, -1L, 1L, -1L)
surPar_cat <-getSurrogates(ncat = as.integer(ncat2),
wt = as.numeric(wt),
X = as.matrix(testdata),
controls = as.integer(unlist(controls)),
var = as.integer(var),
split = as.numeric(split_for_cat))
surPar_cat
dyn.load("integrating2.so")
getSurrogates <- function(ncat, wt, X, controls, var, split) {
.Call("getSurrogates", ncat, wt, X, controls, var, split)
}
maxsur <- 10
sur_agree <- 0
wt <- rep(c(1), 100)
controls <- c(maxsur, sur_agree)
ncat2 <- c(4, 4, 4, rep(0L, 17))
cat_direction2 <- c(4L, -1L, -1L, 1L, -1L)
controls <- c(maxsur, sur_agree)
node <- c(3)
var <- c(2)
split_for_cat <- c(4L, -1L, -1L, 1L, -1L)
surPar_cat <-getSurrogates(ncat = as.integer(ncat2),
wt = as.numeric(wt),
X = as.matrix(testdata),
controls = as.integer(unlist(controls)),
var = as.integer(var),
split = as.numeric(split_for_cat))
surPar_cat
dyn.load("integrating2.so")
getSurrogates <- function(ncat, wt, X, controls, var, split) {
.Call("getSurrogates", ncat, wt, X, controls, var, split)
}
maxsur <- 10
sur_agree <- 0
wt <- rep(c(1), 100)
controls <- c(maxsur, sur_agree)
ncat2 <- c(4, 4, 4, rep(0L, 17))
cat_direction2 <- c(4L, -1L, -1L, 1L, -1L)
controls <- c(maxsur, sur_agree)
node <- c(3)
var <- c(3)
split_for_cat <- c(4L, -1L, -1L, 1L, -1L)
surPar_cat <-getSurrogates(ncat = as.integer(ncat2),
wt = as.numeric(wt),
X = as.matrix(testdata),
controls = as.integer(unlist(controls)),
var = as.integer(var),
split = as.numeric(split_for_cat))
surPar_cat
dyn.load("integrating2.so")
getSurrogates <- function(ncat, wt, X, controls, var, split) {
.Call("getSurrogates", ncat, wt, X, controls, var, split)
}
maxsur <- 10
sur_agree <- 0
wt <- rep(c(1), 100)
controls <- c(maxsur, sur_agree)
ncat2 <- c(4, 4, 4, rep(0L, 17))
cat_direction2 <- c(4L, -1L, -1L, 1L, -1L)
controls <- c(maxsur, sur_agree)
node <- c(3)
var <- c(3)
split_for_cat <- c(4L, -1L, -1L, 1L, -1L)
surPar_cat <-getSurrogates(ncat = as.integer(ncat2),
wt = as.numeric(wt),
X = as.matrix(testdata),
controls = as.integer(unlist(controls)),
var = as.integer(var),
split = as.numeric(split_for_cat))
surPar_cat
=======
res = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
>>>>>>> SMD_0.2.1_LCJ_2
res$var
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 5, ntree = 10, method.sel = "permutation")
res$var
res$var
res
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mgi(x = x, y = class,s = 5, ntree = 10, method.sel = "permutation", type = "classification")
res$var
>>>>>>> c43f67775309b4b7c912faaf5b00fc3d7da291be
