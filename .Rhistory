surr=lapply(nodes,"[",-c(1:7)) # extract surrogates
sum=0
for (o in 1:length(s)) {
if (s[o]==0) next
adjtree.k=rep(0,length(variables))
surr.var=surr[[o]][(1:s[o])]
surr.adj=surr[[o]][(s[o]+1):(2*s[o])]
adjtree.k[surr.var]=surr.adj
adjtree=adjtree+adjtree.k
sum=sum+1
}
adjtree=adjtree/sum
}
#there is one nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
surr=sapply(nodes,"[",-c(1:7)) # extract surrogates
if ((length(nodes[[1]]))>7){
s=(length(surr))/2
surr.var=surr[1:s]
surr.adj=surr[(s+1):(2*s)]
adjtree[surr.var]=surr.adj
}
}
#there is no nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==0){
adjtree=rep(NA,length(variables))
surr.mean=NA
}
return(adjtree=adjtree)
}
#' adj.mean
#'
#' This is an internal function
#'
#' @keywords internal
adj.mean=function(trees){
adj.trees=sapply(1:length(trees),adj.mean.trees,trees)
}
#' adj.mean.trees
#'
#' This is an internal function
#'
#' @keywords internal
adj.mean.trees=function(t,trees){
tree=trees[[t]]
nonterminal.nodes=tree[which(sapply(tree,"[[","status")==1)]
surr.nonterminal=lapply(nonterminal.nodes,"[",-c(1:7))
adj.tree=mean(unlist(lapply(1:length(surr.nonterminal),adj.node,surr.nonterminal)),na.rm = TRUE)
if (adj.tree == "NaN") {
adj.tree = NA
}
return(adj.tree)
}
#' adj.node
#'
#' This is an internal function
#'
#' @keywords internal
adj.node=function(m,surr.nonterminal){
surr=surr.nonterminal[[m]]
if (length(surr)!=0){
num.surr=length(surr)/2
adj=surr[(num.surr+1):(2*num.surr)]
}
if (length(surr)==0){
adj=NA
}
return(adj)
}
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
results.allvar = t(sapply(1:length(index.variables),maa.p,allvariables,ntree,trees,index.variables,candidates,num.threads))
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
variables = allvariables
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
results.allvar = t(sapply(1:length(index.variables),maa.p,allvariables,ntree,trees,index.variables,candidates,num.threads))
index.variables
p = 1
i=index.variables[p]
i=index.variables[p]
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
tree = trees[1]
adjtree=rep(0,length(variables))
adjtree
# there are more than one nonterminal nodes with split variable i
if (length(which(sapply(tree,"[[",4)==i))>1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
s=sapply(nodes,length)
s=(s-7)/2
surr=lapply(nodes,"[",-c(1:7)) # extract surrogates
sum=0
for (o in 1:length(s)) {
if (s[o]==0) next
adjtree.k=rep(0,length(variables))
surr.var=surr[[o]][(1:s[o])]
surr.adj=surr[[o]][(s[o]+1):(2*s[o])]
adjtree.k[surr.var]=surr.adj
adjtree=adjtree+adjtree.k
sum=sum+1
}
adjtree=adjtree/sum
}
#there is one nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
surr=sapply(nodes,"[",-c(1:7)) # extract surrogates
if ((length(nodes[[1]]))>7){
s=(length(surr))/2
surr.var=surr[1:s]
surr.adj=surr[(s+1):(2*s)]
adjtree[surr.var]=surr.adj
}
}
#there is no nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==0){
adjtree=rep(NA,length(variables))
surr.mean=NA
}
surrMatrix=matrix(unlist(lapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
surrMatrix=matrix(unlist(lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
surrMatrix=parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)
surrMatrix=lapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
tree
tree = trees[[1]]
trees
trees
forest$trees
trees = forest$trees
ntree=length(trees)
surr.result=rep(NA,length(allvariables))
index.variables=match(variables,allvariables)
if (is.null(num.threads)) {
num.threads = parallel::detectCores()
}
tree = trees[1]
tree
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
tree
surrMatrix=lapply(tree,surr.tree,allvariables,ntree,i)
t
i
trees
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
i=index.variables[p]
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
i
#' surr.tree
#'
#' This is an internal function
#'
#' @keywords internal
surr.tree=function(tree,variables,ntree,i){
adjtree=rep(0,length(variables))
# there are more than one nonterminal nodes with split variable i
if (length(which(sapply(tree,"[[",4)==i))>1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
s=sapply(nodes,length)
s=(s-7)/2
surr=lapply(nodes,"[",-c(1:7)) # extract surrogates
sum=0
for (o in 1:length(s)) {
if (s[o]==0) next
adjtree.k=rep(0,length(variables))
surr.var=surr[[o]][(1:s[o])]
surr.adj=surr[[o]][(s[o]+1):(2*s[o])]
adjtree.k[surr.var]=surr.adj
adjtree=adjtree+adjtree.k
sum=sum+1
}
adjtree=adjtree/sum
}
#there is one nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==1){
nodes=tree[which(sapply(tree,"[[",4)==i)]
surr=sapply(nodes,"[",-c(1:7)) # extract surrogates
if ((length(nodes[[1]]))>7){
s=(length(surr))/2
surr.var=surr[1:s]
surr.adj=surr[(s+1):(2*s)]
adjtree[surr.var]=surr.adj
}
}
#there is no nonterminal node with split variable i
if (length(which(sapply(tree,"[[",4)==i))==0){
adjtree=rep(NA,length(variables))
surr.mean=NA
}
return(adjtree=adjtree)
}
surrMatrix=lapply(trees[1:ntree],surr.tree,allvariables,ntree,i)
View(surrMatrix)
surrMatrix=matrix(unlist(parallel::mclapply(trees[1:ntree],mc.cores = num.threads,surr.tree,allvariables,ntree,i)),ncol=length(allvariables),nrow=ntree,byrow = TRUE)
View(surrMatrix)
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100)
res$var
13 * 97.33
13 * 97.33 / 22.362
0.328/0.175
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
data = SMD_example_data
x = data[,2:ncol(data)]
y = data[,1]
ntree = 10
type = "regression"
s = 10
mtry = NULL
min.node.size = 1
num.threads = NULL
status = NULL
save.ranger = FALSE
create.forest = TRUE
forest = NULL
save.memory = FALSE
min.var.p = 200
p.t.sel = 0.01
p.t.rel = 0.01
select.var = TRUE
case.weights = NULL
variables = c("X1","X7")
candidates = colnames(x)[1:100]
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
variables = colnames(x)    # extract variables names
nvar = length(variables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*nvar)
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 1)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
trees = getTreeranger(RF = RF,ntree = ntree)
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = x, num.threads = num.threads)
trees = getTreeranger(RF = RF,ntree = ntree)
trees=lapply(1:ntree,getsingletree,RF=RF)
#' getsingletree
#'
#' This is an internal function
#'
#' @keywords internal
getsingletree=function(RF,k=1){
# here we use the treeInfo function of the ranger package to create extract the trees, in an earlier version this was done with a self implemented function
tree.ranger = ranger::treeInfo(RF,tree = k)
ktree=data.frame(as.numeric(tree.ranger$nodeID+1),
as.numeric(tree.ranger$leftChild+1),
as.numeric(tree.ranger$rightChild+1),
as.numeric(tree.ranger$splitvarID+1),
tree.ranger$splitval,
tree.ranger$terminal)
ktree[,5] = as.character(levels(ktree[,5] ))[ktree[,5]]
ktree[,6] = as.numeric(ktree[,6] == FALSE)
for (i in 2:4) {
ktree[,i][is.na(ktree[,i])] = 0
}
colnames(ktree)=c("nodeID","leftdaughter","rightdaughter","splitvariable","splitpoint","status")
return(ktree)
}
trees=lapply(1:ntree,getsingletree,RF=RF)
k = 1
tree.ranger = ranger::treeInfo(RF,tree = k)
ktree=data.frame(as.numeric(tree.ranger$nodeID+1),
as.numeric(tree.ranger$leftChild+1),
as.numeric(tree.ranger$rightChild+1),
as.numeric(tree.ranger$splitvarID+1),
tree.ranger$splitval,
tree.ranger$terminal)
View(ktree)
ktree[,5] = as.character(levels(ktree[,5] ))[ktree[,5]]
View(ktree)
ktree[,6] = as.numeric(ktree[,6] == FALSE)
?getTreeranger
for (i in 2:4) {
ktree[,i][is.na(ktree[,i])] = 0
}
ktree[,5] = levels(ktree[,5])[ktree[,5]]
View(ktree)
# here we use the treeInfo function of the ranger package to create extract the trees, in an earlier version this was done with a self implemented function
tree.ranger = ranger::treeInfo(RF,tree = k)
ktree=data.frame(as.numeric(tree.ranger$nodeID+1),
as.numeric(tree.ranger$leftChild+1),
as.numeric(tree.ranger$rightChild+1),
as.numeric(tree.ranger$splitvarID+1),
tree.ranger$splitval,
tree.ranger$terminal)
ktree[,5] = levels(ktree[,5])[ktree[,5]]
ktree[,6] = as.numeric(ktree[,6] == FALSE)
for (i in 2:4) {
ktree[,i][is.na(ktree[,i])] = 0
}
colnames(ktree)=c("nodeID","leftdaughter","rightdaughter","splitvariable","splitpoint","status")
tree.ranger = ranger::treeInfo(RF,tree = k)
ktree=data.frame(as.numeric(tree.ranger$nodeID+1),
as.numeric(tree.ranger$leftChild+1),
as.numeric(tree.ranger$rightChild+1),
as.numeric(tree.ranger$splitvarID+1),
tree.ranger$splitval,
tree.ranger$terminal)
ktree[,5] = as.character(levels(ktree[,5] ))[ktree[,5]]
as.character(levels(ktree[,5] ))[ktree[,5]]
levels(ktree[,5] ))[ktree[,5]
(is.factor(ktree[,5]))
if (is.factor(ktree[,5])) {
ktree[,5] = as.character(levels(ktree[,5] ))[ktree[,5]]
}
library(SurrogateMinimalDepth)
if (is.factor(ktree[,5])) {
ktree[,5] = as.character(levels(ktree[,5] ))[ktree[,5]]
}
trees = getTreeranger(RF = RF,ntree = ntree)
trees[[1]]
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = x, num.threads = num.threads)
library("SurrogateMinimalDepth")
library("ranger")
data("SMD_example_data")
class = c(rep(1,50),rep(0,50))
restvar = SMD_example_data[,184:200]
var.1 = c(rep("A",25),rep("B",25),rep("C",25),rep("D",25))
var.2 = c(rep("C",25),rep("A",25),rep("D",25),rep("B",25))
#erste variable
var.1[c(9,13,17,24)] = "C"
var.1[c(3,4)] = "D"
var.1[c(6)] = "B"
var.2[c(9,13,17,24)] = "D"
var.2[c(3,4)] = "B"
var.2[c(6)] = "A"
#zweite variable
var.1[c(27,33,38,41,44)] = "C"
var.1[30] = "D"
var.1[c(35,48)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "B"
var.2[c(35,48)] = "C"
#dritte variable
var.1[c(59,63,67,74)] = "A"
var.1[c(53,54)] = "B"
var.1[56] = "D"
var.2[c(59,63,67,74)] = "C"
var.2[c(53,54)] = "A"
var.2[56] = "B"
#vierte variable
var.1[c(77,83,88,91,94)] = "C"
var.1[80] = "B"
var.1[c(85,98)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "A"
var.2[c(35,48)] = "C"
testdata = cbind(var.1,var.2,var.1,restvar)
rownames(testdata) = paste0("sample_",c(1:100))
colnames(testdata) = paste0("variable_",c(1:20))
data
class(data)
x = testdata
y = class
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
variables = colnames(x)    # extract variables names
nvar = length(variables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*nvar)
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 1)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
type = classification
type = "classification"
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
variables = colnames(x)    # extract variables names
nvar = length(variables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*nvar)
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 1)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
mtry
mtry = 5
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
keep.inbag = TRUE, num.threads = num.threads, case.weights = case.weights, respect.unordered.factors = "partition")
trees = getTreeranger(RF = RF,ntree = ntree)
trees[[1]]
trees.lay = addLayer(trees)
rm(trees)
###AddSurrogates###
trees.surr = addSurrogates(RF = RF,trees = trees.lay,s = s,Xdata = x, num.threads = num.threads)
library(SurrogateMinimalDepth)
