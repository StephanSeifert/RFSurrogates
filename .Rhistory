var.1[80] = "B"
var.1[c(85,98)] = "A"
var.2[c(27,33,38,41,44)] = "D"
var.2[30] = "A"
var.2[c(35,48)] = "C"
testdata = cbind(var.1,var.2,var.1,restvar)
rownames(testdata) = paste0("sample_",c(1:100))
colnames(testdata) = paste0("variable_",c(1:20))
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = testdata, y = class,s = 10, ntree = 10)
res$var
setwd("~/Projekte/mutualginiimpurity/subprojects/02_SimStudy2_CategoricalVariables/scripts")
simulate_data_class = function(i,no.samp,simdata.dir){
X1 = as.character(sample(c(1,2),no.samp,prob=c(0.5,0.5),replace =TRUE))
X2 = as.character(sample(seq(1:3),no.samp,prob=c(rep(1/3,3)),replace =TRUE))
X3 = as.character(sample(seq(1:4),no.samp,prob=c(rep(1/4,4)),replace =TRUE))
X4 = as.character(sample(seq(1:5),no.samp,prob=c(rep(1/5,5)),replace =TRUE))
X5 = as.character(sample(seq(1:6),no.samp,prob=c(rep(1/6,6)),replace =TRUE))
X6 = as.character(sample(seq(1:7),no.samp,prob=c(rep(1/7,7)),replace =TRUE))
X7 = as.character(sample(seq(1:8),no.samp,prob=c(rep(1/8,8)),replace =TRUE))
X8 = as.character(sample(seq(1:9),no.samp,prob=c(rep(1/9,9)),replace =TRUE))
X9 = as.character(sample(seq(1:10),no.samp,prob=c(rep(1/10,10)),replace =TRUE))
X10 = rnorm(no.samp)
Y = sample(c(0,1),no.samp,prob=c(0.5,0.5),replace =TRUE)
data=data.frame(Y,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10)
saveObject(data,file=file.path(simdata.dir,paste0("data_",i,".RData")))
return(invisible(NULL))
}
source("init.R")
rerun = FALSE
library(ranger)
library(SurrogateMinimalDepth)
no.samp = 100
rep = 1000
simdata.dir = set.dir(file.path(data.dir, "categories_class"))
set.seed(42)
lapply(1:rep, simulate_data_class,no.samp,simdata.dir)
mtry = 3
ntree = 50
s = 3
type = "classification"
files.dir = set.dir(file.path(data.dir, paste0("class_ntree_",ntree,"_mtry_",mtry,
"_s_",s,"_rep_",rep)))
i = 1
data = loadObject(file=file.path(simdata.dir,paste0("data_",i,".RData")))
x = data[,-1]
y = data[,1]
nvar=ncol(x)
res.mir = var.select.mir(x = x,
y = y,
mtry = mtry,
ntree = ntree,
type = type,
s = s,
select.var = FALSE)
library(SurrogateMinimalDepth)
var.select.mir()
?var.select.mir
?rm
?var.select.mir
?rm
?var.select.mir
?var.relations.mfi
?var.select.mir
library(SurrogateMinimalDepth)
load("/home/stephan/Projekte/mutualginiimpurity/subprojects/03_ComparisonStudy_SimStudy3/data_input/Simfromreal/effects_-2_-1_-0.5_0.5_1_2/samples_200/causal.var_150/input/sim_data_rep_1_test.RData")
data =saveLoadReference
class(data)
sim.data.l = NULL
name = c("train", "test")
input.dir = "/home/stephan/Projekte/mutualginiimpurity/subprojects/03_ComparisonStudy_SimStudy3/data_input/Simfromreal/effects_-2_-1_-0.5_0.5_1_2/samples_200/causal.var_150/input"
for (i in 1:2) {
sim.file = file.path(input.dir, paste0("sim_data_rep_", rep, "_", name[i], ".RData"))
if (!file.exists(sim.file)) {
stop(paste("simulation data file", sim.file, "does not exist!"))
}
sim.data = loadObject(file = sim.file)
sim.data.l = c(sim.data.l, list(sim.data))
}
rep = 1
for (i in 1:2) {
sim.file = file.path(input.dir, paste0("sim_data_rep_", rep, "_", name[i], ".RData"))
if (!file.exists(sim.file)) {
stop(paste("simulation data file", sim.file, "does not exist!"))
}
sim.data = loadObject(file = sim.file)
sim.data.l = c(sim.data.l, list(sim.data))
}
library(R.utils)       ## loadObject(), saveObject()
library(Pomona)
library(SurrogateMinimalDepth)
library(ranger)
for (i in 1:2) {
sim.file = file.path(input.dir, paste0("sim_data_rep_", rep, "_", name[i], ".RData"))
if (!file.exists(sim.file)) {
stop(paste("simulation data file", sim.file, "does not exist!"))
}
sim.data = loadObject(file = sim.file)
sim.data.l = c(sim.data.l, list(sim.data))
}
View(sim.data.l)
nr
nr = 1
data.sets = 1:2
output.prefix = file.path(output.dir, paste0("results_rep_", rep, "_data_set_", nr))
data.train = sim.data.l[[nr]]
data.test = sim.data.l[[setdiff(data.sets, nr)]]
View(data.train)
class(data.train)
?apply
library(SurrogateMinimalDepth)
source("init.R")
library(ranger)
library(SurrogateMinimalDepth)
no.samp = 100
rep = 1000
mtry = 3
ntree = 50
s = 3
groupnames = c("M(2)","M(3)","M(4)","M(5)","M(6)","M(7)","M(8)","M(10)","M(20)","N(0,1)")
simulation = "categories"
type = "classification"
simdata.dir = set.dir(file.path(data.dir, paste0(simulation,"_type_",type)))
data = loadObject(file=file.path(simdata.dir,paste0("data_",i,".RData")))
x = data[,-1]
y = data[,1]
nvar=ncol(x)
i = 1
data = loadObject(file=file.path(simdata.dir,paste0("data_",i,".RData")))
x = data[,-1]
y = data[,1]
nvar=ncol(x)
res.smd = var.select.smd(x = as.data.frame(x),
y = y,
mtry = mtry,
ntree = ntree,
type = type,
s = s)
library(SurrogateMinimalDepth)
var.select.smd
?var.select.smd
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.smd(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 1000)
res$var
?var.select.mir
library(SurrogateMinimalDepth)
?var.select.mir
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
res$info$relations$surr.res
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 1000)
res$var
res$info$relations$surr.res
res$info$relations$surr.res[,1]
res$info$relations$surr.res[1,]
library(SurrogateMinimalDepth)
meanAdjAgree()
meanAdjAgree
?var.relations
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100], t = 5)
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100], t = 5)
res$var
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100], t = 5)
res$var
res = var.relations(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100], t = 5)
?ranger
library(SurrogateMinimalDepth)
?var.relations.mfi
library(SurrogateMinimalDepth)
?var.select.mir
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
devtools::document()
library(SurrogateMinimalDepth)
?var.select.mir
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100, method.sel = "permutation")
res$var
library(SurrogateMinimalDepth)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100, method.sel = "permutation")
res$var
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100,)
res$var
library(ranger)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 1000)
res$var
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 1000, method.sel = "permutation")
res$var
?importance_pvalues
importance_pvalues
library(SurrogateMinimalDepth)
?var.relations.mfi
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100], method = "permutation")
res$var.rel[[1]]
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
?var.relations
?var.relations.mfi
devtools:document()
library(devtools)
devtools::document()
library(SurrogateMinimalDepth)
?var.relations.mfi
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
res$surr.perm
?var.select.mir
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100,method = "permutation")
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100, method.sel = "permutation")
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
adj.agree_perm = res$surr.perm
diag(adj.agree_perm) = 0
#'
#' This is an internal function
#'
#' @keywords internal
calculate.mir.perm = function(r=1, adj.agree_perm, air, allvariables) {
mir.perm = colSums(adj.agree_perm * sample(air,length(air)))
return(mir.perm)
}
diag(adj.agree_perm) = 0
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
num.permutation = 100
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
num.permutations = 100
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
ntree = 100
type = "regression"
s = 10
mtry = NULL
min.node.size = 1
num.threads = NULL
status = NULL
save.ranger = FALSE
save.memory = FALSE
min.var.p = 200
p.t.sel = 0.01
p.t.rel = 0.01
select.var = TRUE
select.rel = FALSE
case.weights = NULL
corr.rel = FALSE
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t, select.rel = select.rel)
}
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t,select.rel = select.rel)
}
}
adj.agree = rel$surr.res
diag(adj.agree) = 1
mir = colSums(adj.agree * RF$variable.importance)
if (select.var) {
if (method.sel == "janitza") {
if (corr.rel) {
## Mirrored VIMP (# This part is taken from ranger function)
m1 = mir[mir< 0]
m2 = mir[mir == 0]
null.rel = c(m1, -m1, m2)
pval <- 1 - ranger:::numSmaller(mir, null.rel) / length(null.rel)
names(pval) = allvariables
selected = as.numeric(pval <= p.t.sel)
names(selected) = names(pval)
if (length(m1) == 0) {
stop("No negative importance values found for selection of important variables. Consider the 'permutation' approach.")
}
if (length(m1) < 100) {
warning("Only few negative importance values found for selection of important variables, inaccurate p-values. Consider the 'permutation' approach.")
}
} else {
stop("Janitza approach should only be conducted with corrected relations")
}
}
}
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t, select.rel = select.rel)
}
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t,select.rel = select.rel)
}
}
adj.agree = rel$surr.res
diag(adj.agree) = 1
mir = colSums(adj.agree * RF$variable.importance)
