res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 1000, method.sel = "permutation")
res$var
?importance_pvalues
importance_pvalues
library(SurrogateMinimalDepth)
?var.relations.mfi
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100], method = "permutation")
res$var.rel[[1]]
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
?var.relations
?var.relations.mfi
devtools:document()
library(devtools)
devtools::document()
library(SurrogateMinimalDepth)
?var.relations.mfi
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
res$surr.perm
?var.select.mir
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100,method = "permutation")
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100, method.sel = "permutation")
# read data
data("SMD_example_data")
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
# calculate variable relations
set.seed(42)
res = var.relations.mfi(x = x, y = y, s = 10, ntree = 100, variables = c("X1","X7"), candidates = colnames(x)[1:100])
res$var.rel[[1]]
adj.agree_perm = res$surr.perm
diag(adj.agree_perm) = 0
#'
#' This is an internal function
#'
#' @keywords internal
calculate.mir.perm = function(r=1, adj.agree_perm, air, allvariables) {
mir.perm = colSums(adj.agree_perm * sample(air,length(air)))
return(mir.perm)
}
diag(adj.agree_perm) = 0
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
num.permutation = 100
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
num.permutations = 100
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
ntree = 100
type = "regression"
s = 10
mtry = NULL
min.node.size = 1
num.threads = NULL
status = NULL
save.ranger = FALSE
save.memory = FALSE
min.var.p = 200
p.t.sel = 0.01
p.t.rel = 0.01
select.var = TRUE
select.rel = FALSE
case.weights = NULL
corr.rel = FALSE
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t, select.rel = select.rel)
}
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t,select.rel = select.rel)
}
}
adj.agree = rel$surr.res
diag(adj.agree) = 1
mir = colSums(adj.agree * RF$variable.importance)
if (select.var) {
if (method.sel == "janitza") {
if (corr.rel) {
## Mirrored VIMP (# This part is taken from ranger function)
m1 = mir[mir< 0]
m2 = mir[mir == 0]
null.rel = c(m1, -m1, m2)
pval <- 1 - ranger:::numSmaller(mir, null.rel) / length(null.rel)
names(pval) = allvariables
selected = as.numeric(pval <= p.t.sel)
names(selected) = names(pval)
if (length(m1) == 0) {
stop("No negative importance values found for selection of important variables. Consider the 'permutation' approach.")
}
if (length(m1) < 100) {
warning("Only few negative importance values found for selection of important variables, inaccurate p-values. Consider the 'permutation' approach.")
}
} else {
stop("Janitza approach should only be conducted with corrected relations")
}
}
}
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t, select.rel = select.rel)
}
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t,select.rel = select.rel)
}
}
adj.agree = rel$surr.res
diag(adj.agree) = 1
mir = colSums(adj.agree * RF$variable.importance)
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10)
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 10, method.sel = "permutation")
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100, method.sel = "permutation")
res$var
x = SMD_example_data[,2:ncol(SMD_example_data)]
y = SMD_example_data[,1]
ntree = 100
type = "regression"
s = 10
mtry = NULL
min.node.size = 1
num.threads = NULL
status = NULL
save.ranger = FALSE
save.memory = FALSE
min.var.p = 200
p.t.sel = 0.01
p.t.rel = 0.01
select.var = TRUE
select.rel = FALSE
case.weights = NULL
corr.rel = FALSE
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t, select.rel = select.rel)
}
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t,select.rel = select.rel)
}
}
adj.agree = rel$surr.res
diag(adj.agree) = 1
mir = colSums(adj.agree * RF$variable.importance)
corr.rel
corr.rel = TRUE
if(!is.data.frame(x)){
stop("x has to be a data frame")
}
## check data
if (length(y) != nrow(x)) {
stop("length of y and number of rows in x are different")
}
if (any(is.na(x))) {
stop("missing values are not allowed")
}
allvariables = colnames(x)# extract variables names
nvar = length(allvariables)   # count number of variables
## set global parameters
if (is.null(mtry)) {
mtry = floor((nvar)^(3/4))
}
if (mtry == "sqrt") {
mtry = floor(sqrt(nvar))
}
if (mtry == "0.5") {
mtry = floor(0.5*(nvar))
}
if (mtry == "^3/4") {
mtry = floor((nvar)^(3/4))
}
if (is.null(s)) {
s = ceiling(nvar*0.01)
}
if (s > (nvar - 2)) {
s = nvar - 1
warning("s was set to the maximum number that is reasonable (variables-1) ")
}
if (type == "classification") {
y = as.factor(y)
if (length(levels(y)) > 15) {
stop("Too much classes defined, classification might be the wrong choice")
}
}
if (type == "regression" && class(y) == "factor") {
stop("use factor variable for y only for classification! ")
}
data = data.frame(y, x)
if (type == "survival") {
if (is.null(status)) {
stop("a status variable named status has to be given for survival analysis")
}
data$status = status
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, status.variable.name = "status", save.memory = save.memory,
importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, status = status, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t, select.rel = select.rel)
}
}
if (type == "classification" | type == "regression") {
RF = ranger::ranger(data = data,dependent.variable.name = "y",num.trees = ntree,mtry = mtry,min.node.size = min.node.size,
num.threads = num.threads, importance ="impurity_corrected", case.weights = case.weights, respect.unordered.factors = "partition")
if (corr.rel) {
rel = var.relations.mfi(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, p.t = p.t.rel, method = method.rel,select.rel = select.rel)
} else {
rel = var.relations(x = x, y = y, ntree = ntree, type = type, s = s, mtry = mtry, min.node.size = min.node.size,
num.threads = num.threads, case.weights = case.weights, variables = allvariables,
candidates = allvariables, t = t,select.rel = select.rel)
}
}
adj.agree = rel$surr.res
diag(adj.agree) = 1
mir = colSums(adj.agree * RF$variable.importance)
if (corr.rel){
adj.agree_perm = var.relations.mfi$surr.perm
}
var.relations.mfi
adj.agree_perm = rel$surr.perm
View(adj.agree_perm)
diag(adj.agree_perm) = 0
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
#'
#' This is an internal function
#'
#' @keywords internal
calculate.mir.perm = function(r=1, adj.agree_perm, air, allvariables) {
mir.perm = colSums(adj.agree_perm * sample(air,length(air)))
return(mir.perm)
}
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
num.permutations = 100
null.rel = unlist(lapply(1:num.permutations,calculate.mir.perm,
adj.agree_perm = adj.agree_perm,
air = RF$variable.importance,
allvariables = allvariables))
null.rel
pval <- 1 - ranger:::numSmaller(mir, null.rel) / length(null.rel)
names(pval) = allvariables
selected = as.numeric(pval <= p.t.sel)
names(selected) = names(pval)
pval
library(SurrogateMinimalDepth)
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 100, method.sel = "permutation")
res$var
# read data
data("SMD_example_data")
# select variables (usually more trees are needed)
set.seed(42)
res = var.select.mir(x = SMD_example_data[,2:ncol(SMD_example_data)], y = SMD_example_data[,1],s = 10, ntree = 1000, method.sel = "permutation")
res$var
